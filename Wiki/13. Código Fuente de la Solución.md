## 13.1. Estructura de la solución

```
/PowerPad.Core
    /Contracts
    /Helpers
    /Models
        /AI
        /FileSystem
    /Services
        /AI
        /Config
        /FileSystem
    PowerPad.Core.csproj
/PowerPad.WinUI
    /Assets
        /Background
        /Icons
    /Components
        /Chat 
        /Controls
        /Editors
        /Models
        /Selectors
        /Workspace
    /Configuration
    /Converters
    /Helpers
    /Messages
    /Pages
        /Providers
    /Properties
        /PublishProfiles
    /Styles
    /ViewModels
        /Agents
        /AI
            /Providers
        /Chat
        /FileSystem
        /Settings
    PowerPad.WinUI.csproj
    ...
/Wiki
PowerPad.sln
...
```

El código fuente de la solución está dividido principalmente en dos proyectos: `PowerPad.Core`, que ofrece la lógica de negocio, modelos y servicios base; y `PowerPad.WinUI`, que contiene la interfaz de usuario, controles, viewmodels y recursos visuales. Esta separación facilita el mantenimiento, testing y la extensión a otras plataformas si fuera necesario en el futuro. 
En la raíz encontramos principalmente el fichero principal de la solución para Visual Studio. También encontramos en el mismo repositorio la carpeta `Wiki` con la documentación completa en formato _markdown_.

#### PowerPad.Core

Este proyecto engloba todo el núcleo lógico de la aplicación, gestionando los modelos de datos, contratos de servicios (interfaces), lógica de IA, configuración y manipulación de documentos. En la raíz está el archivo de proyecto, y dentro de las subcarpetas se distribuyen las distintas responsabilidades lógicas.  

- **Contracts**: Define las interfaces y contratos fundamentales que deben implementar los servicios principales como los de IA, editores, chats y gestión de archivos. Permite desacoplar la lógica y facilitar futuras implementaciones o testeo.
- **Helpers**: Utilidades y clases auxiliares para interacción con APIs externas (como HuggingFace o GitHub) y parseo de la web de Ollama.com para búsqueda de modelos.
- **Models**: Contiene los modelos de datos utilizados en el dominio de la aplicación, estructurados a su vez en subcarpetas como `AI` (para agentes, modelos, parámetros de IA) y `FileSystem` (para documentos, carpetas, estados de archivo).
- **Services**: Implementa la lógica de negocio central organizada en varias áreas:
    - **AI**: Servicios que permiten interactuar con los diferentes proveedores de inteligencia artificial (por ejemplo, Ollama o Azure AI).
    - **Config**: Lógica para la gestión, almacenamiento y recuperación de la configuración de la aplicación.
    - **FileSystem**: Servicios para la manipulación del sistema de archivos interno de la aplicación, gestión de documentos, carpetas y su orden.  

#### PowerPad.WinUI

Este proyecto es responsable de la interfaz de usuario, integrando WinUI 3 y MVVM. Incluye los ficheros de recursos gráficos, controles personalizados, páginas, estilos y los viewmodels que enlazan la UI con el core de la aplicación.  

- **Assets**: Almacena todos los recursos visuales: iconos, imágenes (por secciones), temas y fondos empleados en la app.
    - **Background**: Imágenes de fondo para diferentes apartados.
    - **Icons**: Conjunto de iconos SVG y PNG usados en la interfaz.
- **Components**: Reúne los controles personalizados reutilizables organizados por función.
	- **Chat**: Controles reutilizables para la interacción de chat (por ejemplo, ChatControl y similares).
	- **Controls**: Otros controles visuales personalizados, como selectores y botones especiales.
	- **Editors**: Controles de edición tanto para notas como para chats y agentes.
	- **Models**: Controles para gestionar, buscar y añadir modelos de IA.
	- **Workspace**: Controles relacionados con la gestión y visualización del espacio de trabajo y editores.
- **Configuration**: Contiene clases auxiliares y modelos para cargar y manejar la configuración de la app, como ficheros JSON, contextos de serialización y constantes.
- **Converters**: Clases para convertir valores entre tipos, especialmente útiles en el data binding de XAML (por ejemplo, convertir un modelo AI a su fuente visual).
- **Helpers**: Extensiones y utilidades específicas para la UI, como helpers para fondos acrílicos, conversiones, o helpers para la gestión de colecciones observables.
- **Messages**: Define los mensajes y notificaciones usados en el sistema de mensajería interna (por ejemplo, para cambios en carpetas o archivos).
- **Pages**: Todas las páginas y vistas principales de la app, junto con páginas específicas para la gestión de modelos según el proveedor.
    - **Providers**: Páginas especializadas para los distintos proveedores de modelos IA.
- **Properties**: Configuraciones propias del proyecto, como el manifiesto y ajustes de publicación.
    - **PublishProfiles**: Perfiles para publicar en distintas arquitecturas de Windows.
- **Styles**: Diccionarios de estilos y temas XAML reutilizados en toda la app para garantizar una apariencia coherente.
- **ViewModels**: Implementación de la capa MVVM, con subcarpetas para cada área funcional.
	- **Agents**: ViewModels específicos para la gestión y visualización de agentes IA.
	- **AI**: ViewModels para modelos IA, parámetros y menús de selección de modelos.
	- **Providers**: ViewModels especializados para cada proveedor (OpenAI, Ollama, GitHub, HuggingFace...).
	- **Chat**: ViewModels que gestionan la lógica de los chats y mensajes.
	- **FileSystem**: ViewModels ligados a la gestión y presentación de documentos y carpetas.
	- **Settings**: ViewModels dedicados a la configuración general, de IA y de modelos.

Adicionalmente, en la raiz del proyecto se encuentran algunos ficheros importantes, destacando los siguientes:

- **App.xaml / App.xaml.cs**: Definición y lógica del punto de entrada de la aplicación.
- **MainWindow.xaml / PopupWindow.xaml**: Ventanas principales de la aplicación.
- **app.manifest**: Manifiesto de la aplicación para especificar privilegios, compatibilidad y configuración básica en Windows.
- **Package.appxmanifest**: Archivo de configuración del paquete de instalación, usado para definir capacidades, identidad y recursos para el despliegue en Windows.
- **NativeMethods.txt**: El contenido de este archivo informa a la biblioteca `CsWin32` las funciones nativas para las que debe generar el código fuente.

## 13.2. Buenas Prácticas

Durante el desarrollo de PowerPad se ha prestado especial atención a la adopción de buenas prácticas de ingeniería de software, tanto para maximizar la calidad del código como para asegurar su mantenibilidad, escalabilidad y robustez a largo plazo. En esta sección se detallan los principales enfoques y estándares aplicados en el proyecto.

#### Documentación Exhaustiva

Desde las primeras fases del proyecto, uno de los objetivos clave fue garantizar que todo el código fuente estuviera correctamente documentado. Así, cada clase, método, enumeración e interfaz incluye comentarios XML siguiendo el estándar de documentación de .NET. Este enfoque permite no solo facilitar la comprensión del código a otros desarrolladores, sino también aprovechar herramientas de generación automática de documentación (como DocFX, Sandcastle o Doxygen) en caso de necesitar publicar documentación técnica para usuarios o contribuyentes futuros del proyecto.
  
Esta documentación exhaustiva resulta especialmente valiosa en un contexto como PowerPad, donde existen numerosos componentes (servicios de IA, modelos, helpers, etc.) que interactúan entre sí. La claridad en la definición de parámetros, contratos y excepciones facilita la comprensión global del sistema y disminuye la curva de aprendizaje para nuevos colaboradores.

Se ha incluido un anexo con la documentación generada con [Doxygen](https://www.doxygen.nl/) a partir del código fuente con esta técnica.

![[Pasted image 20250530212134.png]]
*Captura de la documentación generada con Doxygen.*

#### Cumplimiento de Reglas de Calidad (SonarQube y Análisis Estático)

A lo largo de todo el ciclo de vida del desarrollo se ha utilizado [**SonarQube IDE**](https://www.sonarsource.com/products/sonarlint/) (anteriormente *SonarLint*) como herramienta principal de análisis estático de código. SonarQube ha permitido detectar y solucionar de forma temprana posibles errores, *code smells*, vulnerabilidades de seguridad y problemas de mantenibilidad en el código C#. El proyecto se mantiene en todo momento sin advertencias ni mensajes de error, lo cual es indicativo de la rigurosidad aplicada en la revisión de la calidad del código.  
  
Más allá del uso básico, se han seguido todas las recomendaciones sugeridas por SonarLint y el analizador de código integrado de Visual Studio, incluyendo aquellas relacionadas con la disposición de miembros, convenciones de nomenclatura, uso adecuado de variables y detección de potenciales fugas de recursos. 

#### Adopción del Estilo y Directrices .NET

Todo el código de PowerPad sigue el **estándar de estilo y recomendaciones de .NET** ([Link 1](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/coding-conventions) y [Link 2](https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/coding-style/identifier-names)), lo que incluye la convención de nombres para clases (PascalCase), métodos, interfaces (I-prefijo), y campos privados (\_underscore para campos privados). Además, la estructura de los archivos y las carpetas en la solución replica el dominio lógico de la aplicación, lo que favorece la localización rápida de cualquier funcionalidad.  

#### Gestión Correcta de Recursos y Uso de Disposables

Un aspecto fundamental del desarrollo en .NET es la correcta gestión de recursos no administrados o recursos que requieren liberación explícita (por ejemplo, streams, objetos que acceden a sistema de archivos, etc.). En PowerPad se han implementado los patrones de `IDisposable`, asegurándose de liberar correctamente los recursos en todos los objetos que lo requieran, como páginas, controladores de editores y helpers que hacen uso de recursos externos.  

Se han utilizado además instrucciones `using var` allí donde resulta apropiado, y aplicado patrones como `Dispose Pattern` en clases que encapsulan recursos gestionados y no gestionados, cumpliendo así con las mejores prácticas para evitar fugas de memoria y garantizar la estabilidad de la aplicación en ejecuciones prolongadas.  

#### Uso de las Últimas Características del Lenguaje C#

PowerPad hace uso extensivo de las capacidades más recientes del lenguaje C#, incorporando **record** y **record struct** para la declaración de modelos inmutables allí donde tiene sentido. Estas estructuras permiten ventajas como la semántica de valor, igualdad estructural y una sintaxis más declarativa, facilitando la implementación de ViewModels, mensajes o contratos de datos que contentan o encapsulen estos registros.  

También se ha hecho aprovechamiento de los constructores primarios, la inicialización de propiedades y las expresiones lambda simplificadas para mejorar la legibilidad, reducir el código y minimizar la complejidad innecesaria.

#### Serialización Robusta y Contextualizada

Para la persistencia de datos y configuración, se ha optado por `System.Text.Json` junto con contextos personalizados mediante la directiva `[JsonSerializable]`, lo que permite una serialización y deserialización más robusta, controlada y eficiente, aprovechando además el source generator para minimizar costes de reflexión y mejorar el rendimiento.

Esto es importante en proyectos que en un futuro puedan ser trasladados a distintas plataformas, ya que el uso de reflexión suele generar advertencias y errores en función de cómo está construida la solución. Con la serialización contextualizada el código de serialización y deserialización es generado en tiempo de compilación, garantizando su funcionamiento en todas las plataformas de destino.

#### Gestión Segura de la Concurrencia

En los servicios de configuración y persistencia se ha puesto especial cuidado en asegurar la **concurrencia segura**. Los accesos a los archivos de configuración están diseñados para evitar condiciones de carrera y sobreescritura accidental de datos, empleando mecanismos de bloqueo (lock/async lock) donde ha sido necesario.  

#### Preparación para la Escalabilidad y Futuras Extensiones

Finalmente, todo el diseño arquitectónico y las buenas prácticas adoptadas están pensadas para permitir la **escalabilidad** futura del proyecto. El desacoplamiento de servicios, la modularidad y la generalización de contratos e interfaces permiten que futuros proveedores de IA, agentes personalizados o nuevas funcionalidades puedan integrarse en PowerPad con el mínimo esfuerzo y sin necesidad de reescribir capas existentes.

## 13.3. Dependencias

**PowerPad.Core**
- HtmlAgilityPack (1.12.1)
- Microsoft.Extensions.AI.Abstractions (9.4.3-preview.1.25230.7)
- Microsoft.Extensions.AI.AzureAIInference (9.4.3-preview.1.25230.7)
- Microsoft.Extensions.AI.OpenAI (9.4.3-preview.1.25230.7)
- OllamaSharp (5.1.14)  

**PowerPad.WinUI**
- CommunityToolkit.Mvvm (8.4.0)
- CommunityToolkit.WinUI.Controls.Primitives (8.2.250402)
- CommunityToolkit.WinUI.Controls.SettingsControls (8.2.250402)
- CommunityToolkit.WinUI.Converters (8.2.250402)
- CommunityToolkit.WinUI.Extensions (8.2.250402)
- CommunityToolkit.WinUI.UI.Controls.Markdown (7.1.2)
- H.NotifyIcon.WinUI (2.3.0)
- Microsoft.Extensions.DependencyInjection (9.0.4)
- Microsoft.Windows.CsWin32 (0.3.183)
- Microsoft.Windows.SDK.BuildTools (10.0.26100.3916)
- Microsoft.WindowsAppSDK (1.7.250401001)
- WinUIEx (2.5.1)  

#### Microsoft.Extensions.AI (Abstractions, AzureAIInference y OpenAI)

Las librerías bajo el espacio de nombres `Microsoft.Extensions.AI` proporcionan una base robusta y extensible para interactuar con servicios modernos de IA, tanto de Microsoft Azure como de OpenAI. Estas librerías abstraen la complejidad de trabajar directamente con las APIs REST de los principales proveedores de LLMs, permitiendo una integración sencilla, segura y mantenible desde aplicaciones .NET.

- **Microsoft.Extensions.AI.Abstractions**: Define las interfaces y contratos necesarios para desacoplar la lógica de negocio de los detalles concretos de cada proveedor de IA. Esto ofrece gran flexibilidad y facilita el soporte a múltiples servicios en un mismo código.
- **Microsoft.Extensions.AI.AzureAIInference**: Implementa el acceso a modelos desplegados en Azure AI, permitiendo realizar inferencias sobre los LLMs alojados en la nube de Microsoft.
- **Microsoft.Extensions.AI.OpenAI**: Permite consumir los servicios de la API de OpenAI (ChatGPT, GPT-4, etc.), exponiendo parámetros como temperatura, tokens, máximos, top-p y más, para controlar el comportamiento del modelo.

En PowerPad, estas dependencias son clave para la funcionalidad de chat con IA, ya que abstraen el acceso a los diferentes modelos y servicios, logrando que el usuario final pueda seleccionar proveedores, agentes y modelos sin preocuparse por las diferencias técnicas entre ellos. Además, la integración facilita configurar claves, endpoints y parámetros de inferencia desde la propia app, incrementando la versatilidad para distintos perfiles de usuario.

#### OllamaSharp

OllamaSharp es una librería C# creada para facilitar el acceso local a modelos de IA a través del servidor Ollama, que permite ejecutar LLMs en el propio equipo sin requerir conexiones a la nube. Está orientada especialmente a casos en los que se busca privacidad, control de datos, o simplemente experimentar con modelos ligeros sin coste asociado de API.

En PowerPad, OllamaSharp es fundamental para ofrecer la experiencia de "IA local". Permite buscar modelos disponibles, descargarlos y gestionarlos automáticamente desde la aplicación, además de lanzar inferencias en tiempo real para responder las consultas del usuario o enriquecer documentos con ayuda IA. Su uso aporta una capa importante de autonomía y privacidad para los usuarios avanzados, complementando los proveedores en la nube.

#### HtmlAgilityPack

HtmlAgilityPack es una librería para análisis, edición y navegación de documentos HTML, similar a cómo funcionan los selectores DOM en navegadores web. Es especialmente útil para extraer datos estructurados de páginas web que no proveen API, o para procesar contenido HTML en bruto.

En PowerPad se utiliza principalmente en los helpers de búsqueda de modelos, ya que para servicios como HuggingFace o el Marketplace de GitHub no siempre existe un endpoint REST fácil de consumir. Mediante HtmlAgilityPack, la app puede parsear las páginas, extraer información clave sobre los modelos y mostrarla al usuario de manera estructurada.

#### CommunityToolkit (MVVM, WinUI, Converters, Extensions...)

La suite CommunityToolkit es un conjunto de librerías ampliamente adoptado en el desarrollo .NET y, especialmente, de aplicaciones modernas de UI como WinUI. En PowerPad destacan los siguientes paquetes:

- **CommunityToolkit.Mvvm**: Implementa patrones avanzados como MVVM (Model-View-ViewModel), comandos, propiedades observables, mensajería desacoplada, y utilidades para la inyección de lógica en interfaces reactivas. Facilita la escalabilidad, mantenibilidad y testabilidad de la app, separando estrictamente la lógica de UI del núcleo funcional.
- **CommunityToolkit.WinUI**: Incluye controles personalizados, primitivas visuales, convertidores de datos y extensiones muy útiles en la construcción de interfaces modernas y responsivas con WinUI 3.
- **CommunityToolkit.WinUI.Converters, Controls.Primitives, SettingsControls, UI.Controls.Markdown**: Diversos módulos que añaden funcionalidad extra, por ejemplo, soporte avanzado para controles de opciones/configuración, renderizado de Markdown en la propia app, y extensiones para manipular la visualización y el comportamiento de los elementos UI.

Estos paquetes permiten que PowerPad tenga una interfaz limpia, atractiva y flexible, además de soportar la edición y renderizado de texto enriquecido, y mantener una experiencia consistente en todo el flujo de trabajo del usuario.

#### H.NotifyIcon.WinUI

Esta librería introduce soporte avanzado para iconos en la bandeja del sistema en aplicaciones WinUI, algo que no está cubierto de forma nativa en la plataforma. Permite mostrar notificaciones, menús contextuales y gestionar el ciclo de vida de la ventana minimizada.

En PowerPad, se utiliza para ofrecer una mejor integración con el sistema operativo, permitiendo que la app permanezca activa en segundo plano con acceso rápido desde la bandeja, ideal para productividad y multitarea.

#### Microsoft.Extensions.DependencyInjection

Esta librería es el estándar de .NET para la inyección de dependencias, un patrón central en la arquitectura moderna y desacoplada. Permite registrar servicios, viewmodels, factories, y resolverlos dinámicamente durante la ejecución.

Su uso en PowerPad es esencial para orquestar la composición de servicios (como los de IA, configuración o almacenamiento) y garantizar un flujo limpio y mantenible en el código, donde los componentes dependen de interfaces y no de implementaciones concretas.

#### Microsoft.WindowsAppSDK

Microsoft.WindowsAppSDK es el framework principal para el desarrollo moderno de aplicaciones Windows nativas con WinUI 3. Ofrece acceso actualizado a APIs de Windows, compatibilidad con nuevos controles, soporte de temas, composición avanzada y mucho más.

PowerPad se apoya totalmente en esta SDK para desarrollar su interfaz, aprovechar efectos visuales como el fondo acrílico, la personalización del sistema de ventanas y la integración profunda con el sistema operativo Windows 11, brindando una experiencia fluida y moderna.

#### WinUIEx

WinUIEx es una colección de utilidades y extensiones que amplía las capacidades nativas de WinUI. Facilita la manipulación avanzada de ventanas, eventos, drag&drop, y customización de la experiencia de usuario más allá de lo que la SDK oficial permite.

En PowerPad se utiliza para enriquecer la interacción del usuario con la ventana principal y los popups, proporcionando una experiencia visual más pulida y adaptable.

#### Otras dependencias

- **Microsoft.Windows.CsWin32**: Genera automáticamente los bindings necesarios para invocar APIs Win32 desde C#. Es útil para integrar ciertas funcionalidades del sistema operativo, como el registro de hotkeys globales.
- **Microsoft.Windows.SDK.BuildTools**: Incluye las herramientas y cabeceras necesarias para compilar y empacar aplicaciones Windows modernas dirigidas a la última versión del sistema.