La arquitectura de PowerPad está diseñada para ofrecer una experiencia de usuario moderna, flexible y extensible, permitiendo la integración avanzada de servicios de inteligencia artificial y la gestión eficiente de documentos y chats. La solución se apoya en una separación clara de responsabilidades, siguiendo los principios SOLID y aprovechando patrones arquitectónicos ampliamente reconocidos en el desarrollo de aplicaciones de escritorio modernas. A continuación se describen los componentes principales que conforman la solución, junto con los patrones de diseño empleados y la organización general de la interfaz y el núcleo de la aplicación.

## 5.1. Descripción de los componentes principales

### 5.1.1. Patrones de diseño utilizados
Para el desarrollo de PowerPad se ha apostado por una arquitectura basada en el patrón MVVM (Model-View-ViewModel), que resulta especialmente adecuado para aplicaciones con interfaces ricas y dinámicas como las que se desarrollan con el marco de trabajo de WinUI. MVVM permite separar de forma clara la lógica de presentación (ViewModel) de la interfaz de usuario (View), facilitando el mantenimiento, la escalabilidad y la prueba de la aplicación. Habitualmente los modelos (Model) encapsulan los datos y la lógica de negocio, aunque en ocasiones se separa la lógica de negocio en servicios específicos, como en nuestro caso. Los ViewModels actúan como intermediarios, exponiendo propiedades y comandos que pueden ser enlazados directamente desde la interfaz.

Además de MVVM, se han incorporado otros patrones y prácticas recomendadas, como la inyección de dependencias, que permite desacoplar la creación y gestión de servicios y facilita la extensión y el testeo de la solución. Para la comunicación entre componentes desacoplados, se utiliza el patrón de mensajería, implementado a través de CommunityToolkit.Mvvm.Messaging, lo que permite que distintos elementos de la aplicación se notifiquen cambios o eventos sin depender directamente unos de otros.

El uso de comandos (RelayCommand) es otra pieza clave, permitiendo que las acciones de la interfaz (como pulsar un botón o seleccionar un elemento) se gestionen de manera desacoplada y testable. Por otro lado, la gestión de recursos y la liberación de memoria se aborda mediante el patrón Disposable, especialmente relevante en una aplicación que maneja múltiples páginas, editores y servicios externos.

Finalmente, se hace un uso intensivo de colecciones observables y propiedades notificables, lo que permite que la interfaz se actualice automáticamente ante cualquier cambio en los datos subyacentes, mejorando la reactividad y la experiencia de usuario.

### 5.1.2. Interfaz
La interfaz de PowerPad está construida sobre WinUI 3, lo que permite aprovechar las capacidades más modernas de diseño y experiencia de usuario en el ecosistema Windows. La aplicación se estructura en torno a una ventana principal (`MainWindow`) que actúa como punto de entrada y contenedor de la navegación lateral, la barra de título personalizada y el área de trabajo principal. Esta ventana principal es responsable de gestionar la navegación entre las distintas páginas y se apoya en un sistema de menús lateral que permite acceder rápidamente a las funcionalidades clave: espacio de trabajo, gestión de modelos, agentes y configuración.

Uno de los aspectos más destacables de la interfaz es la modularidad y reutilización de controles personalizados. Por ejemplo, el control de selección de agentes (`AgentSelector`) y el selector de modelos (`ModelSelector`) permiten al usuario elegir de manera intuitiva entre los agentes y modelos de IA disponibles, mostrando información relevante y facilitando la interacción. El control de chat (`ChatControl`) es otro ejemplo relevante, ya que integra la lógica de conversación con IA, el *streaming* de mensajes y la gestión de parámetros de generación, todo ello presentando una experiencia fluida y visualmente atractiva.

La gestión de documentos y carpetas se realiza a través de un control específico (`WorkspaceControl`), que permite visualizar y manipular la jerarquía de carpetas y documentos mediante operaciones de arrastrar y soltar, renombrado y orden personalizado. Además, la aplicación incluye ventanas emergentes (`PopupWindow`) y diálogos personalizados para tareas como la edición rápida de documentos, la confirmación de acciones o la entrada de texto, mejorando la usabilidad y la productividad.

El diseño visual se apoya en diccionarios de recursos XAML para garantizar la coherencia de estilos, soportando temas claro y oscuro, así como efectos visuales modernos como el fondo acrílico, que contribuyen a una experiencia de usuario actual y agradable. La integración de WebView2, el componente navegador de Microsoft, permite mostrar información detallada de modelos AI directamente de su página web de origen, enriqueciendo la experiencia sin necesidad de salir de la aplicación.

En cuanto a la interacción, se han implementado atajos de teclado globales (*hotkeys*) mediante PInvoke, permitiendo acciones rápidas como copiar contenido o mostrar ventanas emergentes desde cualquier parte del sistema. Todo esto se orquesta a través de ViewModels específicos para cada área funcional (agentes, modelos, chat, documentos, configuración), que exponen las propiedades y comandos necesarios para que la interfaz reaccione de manera dinámica a las acciones del usuario y a los cambios en los datos.

Un ejemplo ilustrativo de esta arquitectura es el flujo de edición de una nota: al seleccionar un documento de tipo nota en el espacio de trabajo, se abre un editor de texto que se comunica con su ViewModel correspondiente. Este ViewModel gestiona el estado del documento, la interacción con los servicios de guardado y autoguardado, y expone comandos para acciones como deshacer o rehacer. Si el usuario decide interactuar con un agente IA desde la nota, el control `NoteAgentControl` permite enviar el contenido al agente seleccionado y recibir sugerencias o ediciones generadas por IA, todo ello gestionado de forma transparente y reactiva.

### 5.1.3. Núcleo
El núcleo de PowerPad, agrupado principalmente en el proyecto `PowerPad.Core`, es el encargado de encapsular la lógica de negocio, la gestión de servicios externos y la definición de los modelos de datos fundamentales. Este núcleo está diseñado para ser completamente independiente de la interfaz, lo que facilita su reutilización, testeo y posible extensión a otras plataformas en el futuro.

Uno de los pilares del núcleo son los servicios de inteligencia artificial, que abstraen la interacción con proveedores externos como Ollama, OpenAI, Azure AI, HuggingFace y GitHub. Cada servicio implementa contratos comunes (por ejemplo, `IAIService`), lo que permite a la aplicación tratar de forma unificada la gestión de modelos, el envío de *prompts* y la recepción de respuestas, independientemente del proveedor subyacente. Esta capa de abstracción es clave para la extensibilidad de la solución, permitiendo añadir nuevos proveedores o modificar los existentes sin impactar en la interfaz ni en el resto de la lógica de negocio.

Junto a los servicios de IA, el núcleo incluye la gestión de documentos y espacio de trabajo. Los documentos y carpetas se representan mediante modelos que encapsulan tanto los datos (contenido, información del archivo, estado de guardado) como la lógica asociada (operaciones de guardado, renombrado, ordenación). La gestión de la estructura jerárquica de carpetas y documentos, así como el soporte para operaciones como arrastrar y soltar, se implementa en servicios especializados que garantizan la integridad y la persistencia de la información.

Otro aspecto relevante del núcleo es la gestión de agentes y modelos AI. Los agentes se definen mediante modelos que incluyen información sobre el prompt inicial, los parámetros de generación y la asociación con modelos específicos. Esto permite a los usuarios crear y personalizar agentes adaptados a distintos contextos de uso, desde asistentes generales hasta agentes especializados en tareas concretas. La gestión de modelos AI, por su parte, incluye la búsqueda, descarga, instalación y eliminación de modelos, así como la configuración de parámetros predeterminados y la comprobación del estado de los servicios.

La configuración y la persistencia de datos se gestionan mediante servicios que abstraen la lectura y escritura de archivos JSON, garantizando la concurrencia segura y la integridad de la información. Estos servicios permiten almacenar y recuperar la configuración de la aplicación, los modelos y agentes definidos por el usuario, y el estado del espacio de trabajo, facilitando la personalización y la continuidad entre sesiones.

Para facilitar la interacción con APIs externas y la manipulación de datos, el núcleo incluye una serie de *helpers* para la integración con las APIs de Hugging Face y GitHub Marketplace para la descarga de modelos, o el scrapping de la web de Ollama.com para consulta de los modelos publicados en su librería (NOTA: a fecha de este proyecto Ollama no ofrece un API para consulta de su librería de modelos). Estas utilidades contribuyen a modularizar la lógica y a evitar la duplicidad de código, mejorando la mantenibilidad y la claridad de la solución.

En resumen, el núcleo de PowerPad actúa como el motor de la aplicación, gestionando la lógica de negocio, la interacción con servicios externos y la persistencia de datos, mientras que la interfaz se encarga de presentar esta información de manera intuitiva y atractiva al usuario. Esta separación de responsabilidades, junto con el uso de patrones de diseño sólidos y tecnologías modernas, permite que PowerPad sea una solución robusta, escalable y preparada para evolucionar en el futuro.

### 5.1.4. Flujo de datos y comunicación interna
El flujo de datos en PowerPad está diseñado para garantizar una comunicación eficiente, desacoplada y reactiva entre los distintos componentes de la aplicación. Esta arquitectura permite que la información fluya de manera coherente desde la interacción del usuario en la interfaz hasta la lógica de negocio y los servicios externos, y viceversa, manteniendo siempre la integridad y la sincronización del estado de la aplicación.

**Comunicación entre la interfaz y el núcleo**

La interacción típica comienza cuando el usuario realiza una acción en la interfaz, como crear un nuevo documento, enviar un mensaje a un agente IA, o modificar la configuración de un servicio. Estas acciones se capturan en los controles y ventanas de la interfaz, que a su vez están enlazados a los *ViewModels* correspondientes mediante *data binding*, el mecanismo que ofrece WinUI para la representación y actualización de información en los controles del interfaz. Los ViewModels actúan como mediadores, exponiendo propiedades y comandos que reflejan el estado de los modelos de datos y encapsulan la lógica necesaria para responder a las acciones del usuario.

Por ejemplo, al enviar un mensaje en un chat, el control de chat notifica al ViewModel, que valida la entrada, actualiza la colección de mensajes y delega la generación de respuesta al servicio de IA correspondiente. El resultado de la operación (la respuesta generada por IA) se propaga de vuelta al ViewModel, que actualiza la interfaz añadiendo el nuevo mensaje a la conversación. Este flujo se apoya en **colecciones observables y propiedades notificables**, lo que permite que la interfaz se actualice automáticamente sin necesidad de lógica adicional.

Para la implementación de estas **colecciones observables y propiedades notificables** se utiliza la librería de `CommunityToolkit.Mvvm` de Microsft (https://learn.microsoft.com/en-us/dotnet/communitytoolkit/mvvm/) que añade a las colecciones y propiedades la lógica necesaria para la comunicar cambios al interfaz mediante código autogenerado.

**Mensajería interna**

Uno de los aspectos clave en la comunicación interna de PowerPad es el uso del patrón de mensajería, implementado mediante `CommunityToolkit.Mvvm.Messaging`. Este sistema permite que distintos componentes de la aplicación se comuniquen entre sí de manera desacoplada, publicando y suscribiéndose a mensajes o eventos de interés.

Este enfoque permite que componente de interfaz distintos respondan de forma coordinada a un cambio en el modelo, aunque no compartan la misma instancia de objeto ViewModel. Un ejemplo claro es cuando modificamos el nombre de un documento, independientemente de que lo hagamos en el editor o en el explorador del espacio de trabajo, se verá reflejado en ambos gracias a que los ViewModels `FolderEntryViewModel` y `DocumentViewModel` se comunican mediante un mensaje de tipo `FolderEntryChanged`.

(añadir diagrama explicando diferencia entre eventos, databinding, mensajería...)

**Flujo de datos con servicios externos**

La comunicación con servicios externos, como los proveedores de IA (Ollama, Azure AI, OpenAI, etc.), se gestiona a través de servicios especializados que implementan interfaces comunes. Cuando el usuario solicita una operación que requiere interacción con un servicio externo (por ejemplo, enviar un *prompt* a un modelo de IA), el ViewModel correspondiente delega la operación al servicio adecuado, que se encarga de construir la petición, enviarla mediante HTTP y procesar la respuesta.

Durante este proceso, se gestionan estados intermedios como la carga o el *streaming* de respuestas, notificando a la interfaz mediante propiedades observables para mostrar indicadores de progreso o actualizar el contenido en tiempo real. Este flujo también contempla la gestión de errores, permitiendo que la interfaz muestre mensajes claros y ayude al usuario a resolver posibles incidencias (como problemas de conexión o autenticación).

**Edición múltiple**

La arquitectura soporta la apertura simultánea de múltiples editores y la gestión de estados independientes para cada uno, persistiendo los editores y gestionando su autoguardado en segundo plano.

De este modo nos aseguramos que, si el usuario abandona una conversación o edición para acudir a otro documento, o incluso a otra parte de la aplicación, como la gestión de modelos, al regresar, no solo verá su documento en el mismo estado, sino que los controles estarán tal y como lo dejó, conservando, por ejemplo, un mensaje sin terminar de enviar.

**Ejemplo de comunicación**

Un caso típico de flujo de datos sería el siguiente:

1. El usuario selecciona un documento en el espacio de trabajo, lo que dispara la apertura del editor correspondiente.
2. El ViewModel del editor carga el modelo del documento utilizando el servicio de documentos y lo expone a la interfaz.
3. El usuario edita el contenido y guarda los cambios, lo que acciona el comando de guardado del ViewModel, que actualiza el modelo y persiste la información mediante el servicio.
4. Si el usuario decide enviar el contenido a un agente IA, el ViewModel del editor delega la operación al servicio de IA, recibe la respuesta y actualiza la interfaz.
5. El usuario cambia el nombre del documento, lo que acciona el comando de renombrado en el ViewModel, que se comunica al resto de la aplicación mediante un mensaje interno.
6. El ViewModel del control explorador del espacio de trabajo recibe el mensaje y notifica el cambio.
7. El control explorador del espacio de trabajo refleja el nuevo nombre modificado.

(Añadir gráfico con la secuencia?)

* * * * *

### 5.1.5. Persistencia
La persistencia de datos en PowerPad es un aspecto fundamental que garantiza la continuidad del trabajo del usuario, la recuperación del estado entre sesiones y la integridad de la información gestionada por la aplicación. El diseño de la persistencia se basa en:

* Fichero de texto para espacio de trabajo: El espacio de trabajo está ubicado en una carpeta del sistema, por defecto se crea una carpeta llamada PowerPad dentro de la ubicación habitual de `Documentos` del usuario, pero el usuario puede cambiar el espacio de trabajo eligiendo otra carpeta.
* Ficheros de texto con formato JSON para almacenar la configuración de la aplicación.

**Persistencia de documentos y espacio de trabajo**

Cada documento y carpeta gestionado por PowerPad se almacena en el sistema de archivos del usuario, siguiendo una estructura jerárquica que refleja la organización del espacio de trabajo. Los documentos pueden ser de dos tipos -nota o chat- y se guardan como archivos individuales, incluyendo el contenido y, para las conversaciones, las opciones seleccionadas (modelo, parámetros, etc). Las carpetas se representan como directorios en el sistema de archivos, permitiendo operaciones como la creación, renombrado, eliminación y movimiento mediante operaciones estándar del sistema.

El servicio de gestión de documentos se encarga de abstraer estas operaciones, proporcionando métodos para cargar, guardar y actualizar documentos y carpetas, así como para gestionar el orden personalizado de las entradas en cada carpeta. Además, se implementa un sistema de guardado automático que asegura que los cambios realizados por el usuario se persisten de manera transparente, minimizando el riesgo de pérdida de información.

**Persistencia de configuración y parámetros**

La configuración global de la aplicación, que incluye aspectos como la lista de modelos y agentes definidos, las claves y URLs de servicios de IA, los parámetros predeterminados de generación y las preferencias de usuario (tema, atajos de teclado, etc.), se almacena en archivos JSON independientes. Esta separación permite que la configuración sea fácilmente editable, portable y recuperable en caso de necesidad.

El servicio de configuración implementa mecanismos para la lectura y escritura concurrente de estos archivos, evitando problemas de corrupción o acceso simultáneo. Además, se emplean técnicas de serialización y deserialización eficientes mediante `System.Text.Json`, con contextos personalizados que optimizan el rendimiento y la compatibilidad.

**Gestión de modelos y agentes**

Los modelos de IA descargados localmente (por ejemplo, mediante Ollama) se gestionan mediante archivos y directorios específicos, permitiendo operaciones como la descarga, instalación, actualización y eliminación de modelos. La información asociada a cada modelo (nombre, proveedor, parámetros, estado) se almacena en archivos JSON, lo que facilita la integración con la interfaz y la gestión centralizada de todos los modelos disponibles.

De forma similar, los agentes definidos por el usuario se persisten en archivos de configuración, permitiendo su recuperación y edición en cualquier momento.

**Sincronización y recuperación de estado**

Al iniciar la aplicación, los servicios de persistencia cargan la configuración, los documentos y el estado del espacio de trabajo desde los archivos correspondientes, reconstruyendo la estructura y el contenido tal y como se encontraba al cerrar la sesión anterior. Cualquier cambio realizado durante el uso de la aplicación se persiste de forma automática o manual, dependiendo de la acción y la configuración establecida.

**Ventajas y consideraciones**

El enfoque basado en archivos JSON y estructura jerárquica en el sistema de archivos ofrece varias ventajas:

- **Portabilidad**: Los datos pueden ser fácilmente respaldados, transferidos o sincronizados entre dispositivos.
- **Transparencia**: El usuario avanzado puede acceder y modificar los archivos directamente si lo desea.
- **Escalabilidad**: La estructura soporta un gran número de documentos y configuraciones sin pérdida de rendimiento.
- **Simplicidad**: Se evita la complejidad de bases de datos externas, facilitando el mantenimiento y la depuración.
- **Rendimiento**: El guardado de la configuración se realiza de forma periódica cuando hay cambios pendientes, en segundo plano, sin interrumpir la actividad del usuario en la interfaz.

No obstante, este enfoque también implica ciertas consideraciones, como la necesidad de gestionar adecuadamente la concurrencia en el acceso a archivos y la integridad de los datos ante posibles interrupciones o cierres inesperados. Por ello, los servicios de persistencia incluyen mecanismos de bloqueo durante la lectura y escritura.

Todos estos componentes de la arquitectura se verán más en detalle en los siguientes apartados.