## 4.1 Enfoque General del Marco

El marco de trabajo **GenCode Framework** surge como una propuesta que unifica las virtudes de la IA generativa con el enfoque _low code_ para agilizar el desarrollo de aplicaciones sin sacrificar la calidad. La idea principal es ofrecer una estructura flexible y modular que de manera intuitiva acelere la creación de aplicaciones, utilizando la inteligencia artificial generativa guiada por un proceso estandarizado que asegure la robustez general de la solución.

Esto lo conseguimos con dos estrategias fundamentales que trabajan en conjunto:

- **Procesamiento del lenguaje natural:**
  Utilizamos la IA generativa donde más valor aporta, el procesamiento del lenguaje natural. La IA interpreta la definición escrita (o hablada) y la traduce en modelos que el sistema puede procesar. Este método permite capturar de forma intuitiva las necesidades del usuario. 
  
- **Construcción del software a partir de modelos:**
  Con los modelos ya definidos, el sistema produce de manera automatizada y determinista las piezas de código necesarias para la aplicación, basándose en componentes configurables y metodologías predefinidas. Así, un modelo de entidad con sus validaciones genera de forma automática toda la estructura para su administración, cumpliendo con estándares de seguridad y coherencia.

En conjunto, ambas estrategias se unen para entregar soluciones más completas y estandarizadas, reduciendo el tiempo invertido en tareas repetitivas y permitiendo que los equipos técnicos se centren en los detalles de mayor complejidad y mayor valor añadido.

(infografía representando las dos estrategias y cómo colaboran para la salida de la solución)

### Componentes Principales

- **Entidades y Modelos de Datos**: Base para la definición de tablas, relaciones y esquemas que describen la información gestionada en la aplicación.

- **Reglas de Negocio**: Se encarga de mantener la coherencia en los procesos mediante restricciones y lógicas bien definidas.

- **Flujos y Disparadores**: Gestionan automatizaciones e interacciones dentro de la aplicación, facilitando la orquestación de tareas.

- **Generación de Interfaces**: Proporciona pantallas y vistas adaptadas a las entidades definidas, acelerando la creación de la capa de presentación.

- **Generación de Informes**: Similar a la generación de interfaces pero orientada a la visualización conjunta de grandes cantidades de datos.

(diagrama de bloques en este punto para visualizar cómo se conectan estos componentes)

### Aportaciones Innovadoras

Algunos de los aspectos que diferencian **GenCode Framework* de otras alternativas son los siguientes:

- **Modelado estándar y flexible**: El marco utiliza esquemas JSON para definir entidades y sus validaciones. Estos esquemas son versionables y definen entidades o documentos que son almacenados en bases de datos NoSQL, permitiendo un manejo de cambios más ágil y adaptable a futuras evoluciones. El versionado de los esquemas ofrece un punto intermedio entre la versatilidad de la gestión de datos no homogéneos y la consistencia dentro de los documentos que pertenecen a una misma versión.

- **APIs orientadas a conversaciones**: El diseño del sistema prioriza la integración con otros sistemas y con asistentes virtuales a través de APIs. Estas interfaces están diseñados de forma consistente en toda la solución, utilizando estándares como REST, OpenAPI y GraphQL y cuidadosamente documentados para facilitar este tipo de integración.

- **Diseño autoreferencial**: Un rasgo distintivo es su capacidad de autorreferencia. Es decir, el propio marco permite su gestión y ampliación con las mismas herramientas que proporciona a los usuarios administradores. Dentro del marco, los esquemas, flujos e interfaces están definidos y estructurados a través de sus respectivos _metamodelos_, que sirven como base para su representación y procesamiento.

### **Flujo de Trabajo Propuesto**

El método de trabajo dentro del marco se concibe como un ciclo iterativo y ajustable a las circunstancias de cada proyecto:

1.  **Modelado inicial**: Definición de las entidades, sus estados y sus relaciones.
2.  **Diseño de reglas de negocio**: Configuración de la lógica y restricciones esenciales.
3.  **Generación de interfaces**: Creación de pantallas y vistas basadas en las entidades definidas.
4.  **Configuración de flujos y disparadores**: Implementación de automatizaciones específicas.
5.  **Generación de informes y notificaciones**: Diseño de cuadros de mando, reportes y notificaciones.
6.  **Pruebas e iteración**: Validación y refinamiento de la aplicación antes de su liberación.

(Se podría mostrar una línea temporal o diagrama de flujo que ilustre cada fase, debería ser iterativa/ciclica)

### **Ejemplo de Caso**

Pensemos en una empresa que requiere un sistema de control de inventario para gestionar productos, almacenes y los movimientos de entrada y salida. Siguiendo el flujo de trabajo indicado anteriormente, el proceso se desarrollaría de la siguiente manera:

1.  **Modelado inicial**:

    -   Se definen las entidades clave: **Producto**, **Almacén** y **Movimiento-Entrada-Salida**.
    -   Cada entidad contempla sus estados y relaciones, por ejemplo: los productos se asocian a uno o varios almacenes, mientras que los movimientos de entrada/salida referencian tanto a un almacén como a la fecha y cantidad transferida.

2.  **Diseño de reglas de negocio**:

    -   Se configuran restricciones para asegurar que no se permitan movimientos con stock negativo.

3.  **Generación de interfaces**:

    -   A partir del modelo, el framework crea de forma automática las pantallas iniciales para registrar, consultar y actualizar la información de productos, así como para manejar los datos de almacenes.

4.  **Configuración de flujos y disparadores**:

    -   Se establecen automatizaciones; por ejemplo, cada vez que se generan registros de entrada/salida, se recalcula el stock en tiempo real.
    -   Si el inventario cae por debajo de cierto nivel, el sistema puede enviar notificaciones al responsable.

5.  **Generación de informes y notificaciones**:

    -   Se diseñan cuadros de mando para visualizar la disponibilidad de productos y tendencias de consumo.
    -   Se diseña un reporte de producto de bajo stock para que se envíe periódicamente a los responsables.

6.  **Pruebas e iteración**:

    -   El equipo valida cada módulo (registro de productos, movimientos de stock, reportes) y realiza ajustes en la configuración de flujos o en la interfaz, asegurando que el sistema cumpla con los requisitos del negocio.
    -   Las mejoras o necesidades adicionales se incorporan de forma ágil gracias al enfoque iterativo, ajustando y extendiendo el modelo inicial según sea necesario.

De esta manera, el **GenCode Framework** acelera la creación de un sistema de control de inventario, permitiendo configurar desde las entidades hasta las notificaciones, todo bajo un enfoque que reduce esfuerzos repetitivos y promueve la coherencia a lo largo del ciclo de desarrollo.

## 4.2 Principios de Estandarización y Modularidad

Como se mencionaba anteriormente, el **GenCode Framework** basa su capacidad de acelerar el desarrollo sin comprometer la calidad en dos estrategias clave: la transformación del lenguaje natural en modelos estructurados y la generación automatizada de software mediante procesos deterministas. Estas estrategias se sustentan en la aplicación rigurosa de principios de **estandarización y modularidad**, que aseguran que los diferentes componentes del sistema sigan patrones bien definidos y uniformes.

La **estandarización** permite que las definiciones proporcionadas en lenguaje natural, una vez procesadas, se conviertan en esquemas formales que guían cada etapa del desarrollo. Este proceso incluye desde el modelado de datos hasta la creación de interfaces de usuario, abarcando incluso la generación de documentación estandarizada. JSON Schema, OpenAPI, GraphQL, son algunos de los estándares que se utilizan en el marco, además especificaciones ampliamente adoptadas en el desarrollo web moderno, como HTML, CSS y ECMAScript, que garantizan compatibilidad y coherencia en las aplicaciones generadas.

(tabla o gráfico que explique como la estandarización facilita la transformación)

Por otro lado, la **modularidad**, en este contexto, se establece como un resultado natural del proceso generativo basado en elementos estandarizados. Cada elemento modelado, como una entidad o un conjunto de entidades afines dentro de un dominio, genera automáticamente un conjunto de componentes cohesionados que incluye modelos de datos, reglas de negocio, interfaces de gestión, etc. Estos módulos pueden operar de forma independiente o integrarse fácilmente gracias a la estandarización del API, garantizando la interoperabilidad y permitiendo la orquestación de flujos de trabajo y consultas transversales entre dominios.

### Estándares Utilizados

**JSON Schema** (*JavaScript Object Notation Schema*)

-   **Descripción**: Especificación que define la estructura y las validaciones de documentos JSON, asegurando la coherencia y la integridad de los datos intercambiados entre los distintos módulos del sistema.
-   **Versión actual**: Draft 2020-12 ([json-schema.org](https://json-schema.org/))

**OpenAPI** (*Open Application Programming Interface Specification*)

-   **Descripción**: Estándar ampliamente adoptado para documentar y definir APIs REST. Proporciona herramientas que facilitan la generación automática de clientes, servidores y pruebas de validación, reduciendo errores de integración.
-   **Versión actual**: 3.1.0 ([openapis.org](https://www.openapis.org/))

**GraphQL** (*Graph Query Language*)

-   **Descripción**: Lenguaje de consulta y manipulación de datos para APIs. Permite a los clientes especificar exactamente qué información necesitan, optimizando el consumo de recursos y minimizando la sobrecarga de datos.
-   **Versión actual**: Especificación viva ([graphql.org](https://graphql.org/))

**HTML5** (*HyperText Markup Language 5*)

-   **Descripción**: Última versión del lenguaje de marcado utilizado para estructurar contenido web. Al ser una especificación "viva", sus funcionalidades se actualizan progresivamente para adaptarse a nuevas necesidades del entorno web.
-   **Versión actual**: Especificación viva ([w3.org](https://www.w3.org/TR/html5/))

**CSS (Módulos de nivel 3 y superiores)** (*Cascading Style Sheets*)

-   **Descripción**: Conjunto de estándares para la definición del estilo y la presentación de contenido HTML. Los módulos más recientes (niveles 4 o superiores) han introducido mejoras importantes en términos de animaciones, diseño responsivo y personalización.
-   **Versión actual**: Especificación viva, dividida en módulos ([w3.org](https://www.w3.org/Style/CSS/Overview.en.html))

**ECMAScript** (*European Computer Manufacturers Association Script*)

-   **Descripción**: Base del lenguaje **JavaScript**, utilizado tanto en aplicaciones del lado cliente como del lado servidor. Las nuevas versiones han introducido características avanzadas que facilitan el desarrollo de aplicaciones web dinámicas y modernas.
-   **Versión actual**: ECMAScript 2022 (13ª edición) ([ecma-international.org](https://www.ecma-international.org/))

**WebAssembly (Wasm)**

-   **Descripción**: Estándar abierto desarrollado por el **W3C** que permite la ejecución de código binario de alto rendimiento en navegadores web. Wasm está diseñado para ser portable, seguro y complementario a JavaScript.
-   **Versión actual**: Release 2.0 (https://webassembly.github.io/spec/core/)

**HTTP/HTTPS** (*HyperText Transfer Protocol / HyperText Transfer Protocol Secure*)

-   **Descripción**: Protocolo fundamental para la transferencia de datos en la web. La versión segura, **HTTPS**, añade una capa de cifrado basado en **SSL/TLS** que protege la integridad y confidencialidad de los datos transmitidos.
-   **Versiones actuales**:
    -   **HTTP/1.1**: Amplia adopción en aplicaciones tradicionales.
    -   **HTTP/2**: Mejora el rendimiento mediante técnicas como multiplexación y compresión de encabezados.
    -   **HTTP/3**: En fase de adopción progresiva, basado en el protocolo QUIC, que promete una mayor eficiencia en conexiones seguras ([ietf.org](https://www.ietf.org/)).

**TLS** (*Transport Layer Security*)

-   **Descripción**: La evolución del antiguo SSL (Secure Sockets Layer), cifra la comunicación mediante certificados digitales que autentican la identidad del servidor, garantizando la privacidad de los datos. 
-   **Versión actual**: TLS 1.3 (RFC 8446) ([ietf.org](https://www.ietf.org/)).

**OAuth 2.0** (*Open Authorization 2.0*)

-   **Descripción**: Protocolo de autorización utilizado para permitir el acceso seguro a recursos de terceros en nombre de un usuario, sin necesidad de exponer sus credenciales. Es un componente esencial en integraciones con plataformas de autenticación externas como Google o Microsoft.
-   **Versión actual**: RFC 6749 ([ietf.org](https://www.ietf.org/))

**JWT** (*JSON Web Tokens*)

-   **Descripción**: Estándar para transmitir información entre partes de manera segura mediante un token firmado. Es comúnmente utilizado en la gestión de sesiones y la autorización de usuarios en entornos distribuidos.
-   **Versión actual**: RFC 7519 ([ietf.org](https://www.ietf.org/))



#### **Justificación y consideraciones en el prototipo**
(No sé si esto iría aquí o en otro apartado del proyecto)

Dado el alcance limitado del prototipo, se ha priorizado la implementación de funcionalidades críticas relacionadas con la comunicación cliente-servidor y la estructura del sistema. Sin embargo, tecnologías como **OAuth 2.0** y **JWT**, a pesar de no estar implementadas directamente en esta fase, han sido consideradas en el diseño general del sistema para facilitar su futura integración. Estos estándares se mencionan para proporcionar un marco teórico sólido y abrir la puerta a mejoras futuras.


> sources
> https://json-schema.org/ https://json-schema.org/specification
> https://www.openapis.org/ https://swagger.io/specification/ https://spec.openapis.org/oas/latest.html
> https://spec.graphql.org/
> WHATWG and W3C. *HTML Living Standard *. [Enlace](https://www.w3.org/TR/html5/)
> W3C. *CSS Snapshot 2023*. [Enlace](https://www.w3.org/TR/css-2023/)
> ECMA International. *ECMAScript® 2025 Language Specification*. [Enlace](https://tc39.es/ecma262/)

## 4.3 Definición de Componentes de Desarrollo

